
## Forecasting with Linear Models

One possible starting point for forecasting problems is to use a linear model,
much like any other predictive modelling with time as an input to the
regression. We account for seasonality by using the various calendar labels as
additional predictors.

Rather than fit the model on the whole dataset, we use the final year of data
as our test dataset.

```{r ap_forecast_regression_data, echo=TRUE}
ap_lm_data_tbl <- airpassengers_tbl %>%
  mutate(month_label = format(month, '%m'),
         year_num    = year(month)
         )

ap_train_tbl <- ap_lm_data_tbl %>% filter(year_num != 1960)
ap_test_tbl  <- ap_lm_data_tbl %>% filter(year_num == 1960)
```

```{r maine_forecast_regression_data, echo=TRUE}
maine_train_tbl <- maine_tbl %>% filter(month <  as.yearmon('2005-01'))
maine_test_tbl  <- maine_tbl %>% filter(month >= as.yearmon('2005-01'))
```



### Simple Linear Model

We now fit a model.

```{r ap_forecast_regression_lm, echo=TRUE}
ap_base_lm <- lm(value ~ 0 + month_label + year_num, data = ap_train_tbl)
```
```{r}
ap_base_lm %>% glance()
ap_base_lm %>% tidy()
```

We now check the fitted values against the observed.

```{r ap_forecast_regression_train, echo=TRUE}
plot_tbl <- ap_base_lm %>%
  augment() %>%
  mutate(month = paste(year_num, month_label, sep = '-') %>% as.yearmon()) %>%
  select(month, observed = value, fitted = .fitted) %>%
  gather('series', 'value', -month)

ggplot(plot_tbl) +
  geom_line(aes(x = month, y = value, colour = series)) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle("Comparison Lineplot of Air Passengers vs Linear Model")
```

We see that the additive model here may be less appropriate as a multiplicative
model as our linear model over-estimates early values and then under-estimates
towards the end of the series.

We expect this will continue when we try the model with the test data.

```{r ap_forecast_regression_test, echo=TRUE}
plot_tbl <- ap_base_lm %>%
  augment(newdata = ap_test_tbl) %>%
  mutate(month = paste(year_num, month_label, sep = '-') %>% as.yearmon()) %>%
  select(month, observed = value, fitted = .fitted) %>%
  gather('series', 'value', -month)

ggplot(plot_tbl) +
  geom_line(aes(x = month, y = value, colour = series)) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle("Comparison Lineplot of Air Passengers vs Linear Model (1960 points)")
```


### Poisson Model

A more appropriate model may be to fit the Poisson model.

```{r ap_forecast_regression_glm, echo=TRUE}
ap_base_glm <- glm(value ~ 0 + month_label + year_num,
                   data   = ap_train_tbl,
                   family = poisson)

ap_base_glm %>% glance()
ap_base_glm %>% tidy()
```

We now check the fitted values against the observed.

```{r ap_forecast_regression_glm_train, echo=TRUE}
plot_tbl <- ap_base_glm %>%
  augment(type.predict = 'response') %>%
  mutate(month = paste(year_num, month_label, sep = '-') %>% as.yearmon()) %>%
  select(month, observed = value, fitted = .fitted) %>%
  gather('series', 'value', -month)

ggplot(plot_tbl) +
  geom_line(aes(x = month, y = value, colour = series)) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle("Comparison Lineplot of Air Passengers vs Poisson Model")
```

We see that a Poisson model does a better job of capturing the magnitude of
the values throughout the series. We hope this means the 1960 data points are
better matched also.

```{r ap_forecast_regression_glm_test, echo=TRUE}
plot_tbl <- ap_base_glm %>%
  augment(newdata = ap_test_tbl, type.predict = 'response') %>%
  mutate(month = paste(year_num, month_label, sep = '-') %>% as.yearmon()) %>%
  select(month, observed = value, fitted = .fitted) %>%
  gather('series', 'value', -month)

ggplot(plot_tbl) +
  geom_line(aes(x = month, y = value, colour = series)) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle("Comparison Lineplot of Air Passengers vs Poisson Model (1960 points)")
```


## Time Series Forecasting

Our main objective in forecasting is to estimate the value of a future
quantity, $x_{n+k}$, given past values ${x_1, x_2, ..., x_n}$. We assume no
seasonal or trend effects, or that such effects are removed from the data.

We assume that the underlying mean of the data is $\mu_t$, and that the value
$x_t$ changes from timestep to timestep, but this change is random.

Our model can be expressed as

$$
x_t = \mu_t + w_t,
$$

where

\begin{eqnarray*}
\mu_t &=&     \text{non-stationary mean of the process at time } t \\
w_t   &\sim&  \mathcal{N}(0, \sigma) \text{ (i.i.d)}
\end{eqnarray*}


### EWMA Models

We let $a_t$ be our estimate of $\mu_t$, and can define the
*exponentially-weighted moving average (EWMA)*, $a_t$ to be

$$
a_t = \alpha x_t + (1 - \alpha) \, a_{t-1}, \;\;\; 0 \leq \alpha \leq 1.
$$

The value of $\alpha$ controls the amount of smoothing, as is referred
to as the *smoothing parameter*. An alternative name for this time-series model
is *simple exponential smoothing (SES)*.

The main package we use for forecasting in R is the `forecast` package,
created by Rob Hyndman. `forecast` contains a convenient framework for
performing most of the task required for time series forecast. We then use
the `sweep` package to bring the outputs into a tidy format where appropriate.

#### Air Passenger Data

We start using the EWMA model on the Air Passenger data.

As a simple approach for testing our models, we remove the final year from the
air passenger data and produce forecasts for those, comparing them to the 
actual values.

```{r ap_ewma_first, echo=TRUE}
ap_ewma_fit <- ap_train_tbl %>%
  tk_ts(select = value, start = 1949, frequency = 12) %>%
  ets(model = 'ANN')

ap_ewma_fit %>% sw_tidy()
ap_ewma_fit %>% sw_glance()
```

Now that we have fit our model we can use the `forecast()` function to produce
forecasts for future times, as well as plotting them.

```{r ap_produce_forecasts, echo=TRUE}
ap_ewma_forecast <- ap_ewma_fit %>%
  forecast(h = 12, level = c(50, 80))

ap_ewma_forecast_tbl <- ap_ewma_forecast %>%
  sw_sweep(rename_index = 'month')


ggplot(ap_ewma_forecast_tbl) +
  geom_line  (aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = ap_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Forecast for Air Passengers with EWMA Model')
```

We see that the EWMA model is not effective in terms prediction.

We can compare the fits against the data directly with `sw_augment()`:

```{r ap_ewma_sweep_augment, echo=TRUE}
ap_ewma_augment_tbl <- ap_ewma_fit %>%
  sw_augment(rename_index = 'month')


ggplot(ap_ewma_augment_tbl) +
  geom_line(aes(x = month, y = .actual)) +
  geom_line(aes(x = month, y = .fitted), colour = 'red') +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Forecast for Air Passengers with EWMA Model')
```




#### Maine Unemployment

We now try the EWMA model on the Maine Unemployment data to see if this model
works any better.

```{r maine_ewma_model, echo=TRUE}
maine_ewma_fit <- maine_train_tbl %>%
  tk_ts(select = value, start = 1996, frequency = 12) %>%
  ets(model = 'ANN')

maine_ewma_fit %>% sw_tidy()
maine_ewma_fit %>% sw_glance()
```

As before, having fit the EWMA model we now produce forecasts.

```{r maine_produce_forecasts, echo=TRUE}
maine_ewma_forecast <- maine_ewma_fit %>%
  forecast(h = 20, level = c(50, 80))

maine_ewma_forecast_tbl <- maine_ewma_forecast %>%
  sw_sweep(rename_index = 'month')


ggplot(maine_ewma_forecast_tbl) +
  geom_line  (aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = maine_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Forecast for Maine Unemployment Data with EWMA Model')
```

In some cases, with such a simple model we may prefer to set values for
$\alpha$ directly rather than fitting it to the data. We do this by passing
the chosen parameters directly into the fitting routine:

```{r maine_ewma_model_set_params, echo=TRUE}
maine_ewma_paramfit <- maine_train_tbl %>%
  tk_ts(select = value, start = 1996, frequency = 12) %>%
  ets(model = 'ANN', alpha = 0.8)

maine_ewma_paramfit %>% sw_tidy()
maine_ewma_paramfit %>% sw_glance()
```

We now produce forecasts using the set EWMA parameter to see how they compare.

```{r maine_produce_paramfit_forecasts, echo=TRUE}
maine_ewma_paramfit_forecast <- maine_ewma_paramfit %>%
  forecast(h = 20, level = c(50, 80))

maine_ewma_paramfit_forecast_tbl <- maine_ewma_paramfit_forecast %>%
  sw_sweep(rename_index = 'month')


ggplot(maine_ewma_paramfit_forecast_tbl) +
  geom_line  (aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = maine_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Forecast for Maine Unemployment Data with Non-Fitted EWMA Model')
```


### Holt-Winters Model

The Holt-Winters method generalises this concept, allowing for trends
and seasonal effects. The equations that govern this model for
seasonal period, $p$, are given by

\begin{eqnarray*}
a_t &=& \alpha (x_t - s_{t-p}) + (1 - \alpha) (a_{t-1} - b_{t-1}),\\
b_t &=& \beta  (a_t - a_{t-1}) + (1 - \beta)  b_{t-1},\\
s_t &=& \gamma (x_t - a_t)     + (1 - \gamma) s_{t-p},
\end{eqnarray*}

where

\begin{eqnarray*}
a_t && \text{is the estimated level at time $t$},\\
b_t && \text{is the estimated slope at time $t$},\\
s_t && \text{is the estimated seasonal effect at time $t$},\\
\alpha, \beta, \gamma && \text{are smoothing parameters}
\end{eqnarray*}

Within the framework of the `forecast` package, we have an additive trend with
an additive seasonal component and additive errors. This corresponds to using
the 'AAA' `ets()` model


#### Air Passenger Data

We start with the Air Passenger data, and use the 'AAA' model within `ets()`.

```{r fit_holtwinters_ts_model, echo=TRUE}
ap_hw_fit <- ap_train_tbl %>%
  tk_ts(select = value, start = 1949, frequency = 12) %>%
  ets(model = 'AAA')

ap_hw_fit %>% sw_tidy()
ap_hw_fit %>% sw_glance()


ap_hw_forecast <- ap_hw_fit %>%
  forecast(h = 12, level = c(50, 80))

ap_hw_forecast_tbl <- ap_hw_forecast %>%
  sw_sweep(rename_index = 'month')


ggplot(ap_hw_forecast_tbl) +
  geom_line  (aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = ap_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Forecast for Air Passengers with Holt-Winters Model')


ap_hw_augment_tbl <- ap_hw_fit %>%
  sw_augment(rename_index = 'month')

ggplot(ap_hw_augment_tbl) +
  geom_line(aes(x = month, y = .actual)) +
  geom_line(aes(x = month, y = .fitted), colour = 'red') +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('sw_augment Output for Holt-Winters Model')
```

For this data the multiplicative trend and errors is not the most appropriate
so we will refit this data with those changes.

Rather than run through the full set of code again we run a more concise
version of this code.

```{r fit_ap_mult_hw, echo=TRUE}
ap_hwmult_fit <- ap_train_tbl %>%
  tk_ts(select = value, start = 1949, frequency = 12) %>%
  ets(model = 'MAM')

ap_hwmult_forecast <- ap_hwmult_fit %>%
  forecast(h = 12, level = c(50, 80))

ap_hwmult_forecast_tbl <- ap_hwmult_forecast %>%
  sw_sweep(rename_index = 'month')


ap_hwmult_fit %>% sw_tidy()
ap_hwmult_fit %>% sw_glance()

ggplot(ap_hwmult_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = ap_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Air Passengers Forecast for Multiplicative Holt-Winters Model')
```


#### Maine Unemployment Data

We now try to fit our models with the Maine Unemployment data, repeating the
process from before.

```{r fit_maine_hw, echo=TRUE}
maine_hw_fit <- maine_train_tbl %>%
  tk_ts(select = value, start = 1996, frequency = 12) %>%
  ets(model = 'ANN')

maine_hw_forecast <- maine_hw_fit %>%
  forecast(h = 20, level = c(50, 80))

maine_hw_forecast_tbl <- maine_hw_forecast %>%
  sw_sweep(rename_index = 'month')


maine_hw_fit %>% sw_tidy()
maine_hw_fit %>% sw_glance()


ggplot(maine_hw_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = maine_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Additive Holt-Winters Model for the Maine Unemployment Data')
```

As before, we can try a multiplicative model.

```{r fit_maine_hwmult, echo=TRUE}
maine_hwmult_fit <- maine_train_tbl %>%
  tk_ts(select = value, start = 1996, frequency = 12) %>%
  ets(model = 'MAM')

maine_hwmult_forecast <- maine_hwmult_fit %>%
  forecast(h = 20, level = c(50, 80))

maine_hwmult_forecast_tbl <- maine_hwmult_forecast %>%
  sw_sweep(rename_index = 'month')


maine_hwmult_fit %>% sw_tidy()
maine_hwmult_fit %>% sw_glance()


ggplot(maine_hwmult_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = maine_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Multiplicative Holt-Winters Model for the Maine Unemployment Data')
```

We see that including a seasonal component into the model improves the
predictions


## Automated Model Selection

The `ets()` function allows us to automatically select a model given the time
series data.

The exponentially-smoothed models fitted allows us to use AIC and BIC as a
decision metric.

The Aikake Information Criterion (AIC) is defined to be:

$$
\text{AIC} = -2 \log(L) + 2k,
$$

where $L$ is the likelihood of the fitted model and $k$ is the number of
degrees of freedom in the model (free parameters, initial states and residual
variance).

For small sample sizes this approach may still be prone to overfitting, so we
may use a corrected version for small-sample bias, ($\text{AIC}_c$)

$$
\text{AIC}_c = \text{AIC} + \frac{k(k+1)}{T - k -1},
$$

The Bayes Information Criterion (BIC) is defined to be:

$$
\text{BIC} = \text{AIC} + k (\log(T) - 2)
$$

The `ets()` model allows us to select the type of error term, trend type and
seasonality, letting us choose additive (A), multiplicative (M), none (N) or
automatically selected (Z) for each of the three options.

The first values, the error term, cannot be 'N' and a number of combinations
are numerically unstable and suppressed.

We now fit both the Air Passenger and Maine Unemployment data using the
automatic model selection.

### Air Passenger Models

We now fit the Air Passenger data first.

```{r fit_ap_auto_ets, echo=TRUE}
ap_autoets_fit <- ap_train_tbl %>%
  tk_ts(select = value, start = 1949, frequency = 12) %>%
  ets(model = 'ZZZ')

ap_autoets_forecast <- ap_autoets_fit %>%
  forecast(h = 12, level = c(50, 80))

ap_autoets_forecast_tbl <- ap_autoets_forecast %>%
  sw_sweep(rename_index = 'month')

ap_autoets_fit %>% sw_tidy()
ap_autoets_fit %>% sw_glance()

ggplot(ap_autoets_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = ap_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Air Passengers Forecast for Automatic ETS Model')
```

Having fit the data and selected the model, we now can compare our different
models and how the forecasts compare to each other.

```{r compare_ap_forecasts, echo=TRUE}
ap_forecast_compare_tbl <- list(
  ewma   = ap_ewma_forecast_tbl    %>% filter(key == 'forecast'),
  hw     = ap_hw_forecast_tbl      %>% filter(key == 'forecast'),
  hwmult = ap_hwmult_forecast_tbl  %>% filter(key == 'forecast'),
  auto   = ap_autoets_forecast_tbl %>% filter(key == 'forecast')
  ) %>%
  bind_rows(.id = 'model') %>%
  mutate(month = as.yearmon(month))


ggplot(ap_forecast_compare_tbl) +
  geom_line(aes(x = month, y = value, colour = model)) +
  geom_line(aes(x = month, y = value), colour = 'black', data = ap_test_tbl) +
  expand_limits(y = 0) +
  scale_x_yearmon() +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Comparison of Air Passenger Forecast Models')
```


### Maine Unemployment Models

We now move on to the Maine Unemployment data, and repeat the procedure.


```{r fit_maine_auto_ets, echo=TRUE}
maine_autoets_fit <- maine_train_tbl %>%
  tk_ts(select = value, start = 1996, frequency = 12) %>%
  ets(model = 'ZZZ')

maine_autoets_forecast <- maine_autoets_fit %>%
  forecast(h = 20, level = c(50, 80))

maine_autoets_forecast_tbl <- maine_autoets_forecast %>%
  sw_sweep(rename_index = 'month')


maine_autoets_fit %>% sw_tidy()
maine_autoets_fit %>% sw_glance()


ggplot(maine_autoets_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = maine_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Maine Unemployment Forecast for Automatic ETS Model')
```

As before, we compare the forecasts against one another.

```{r compare_maine_forecasts, echo=TRUE}
maine_forecast_compare_tbl <- list(
  ewma      = maine_ewma_forecast_tbl          %>% filter(key == 'forecast'),
  ewmaparam = maine_ewma_paramfit_forecast_tbl %>% filter(key == 'forecast'),
  hw        = maine_hw_forecast_tbl            %>% filter(key == 'forecast'),
  hwmult    = maine_hwmult_forecast_tbl        %>% filter(key == 'forecast'),
  auto      = maine_autoets_forecast_tbl       %>% filter(key == 'forecast')
  ) %>%
  bind_rows(.id = 'model') %>%
  mutate(month = as.yearmon(month))


ggplot(maine_forecast_compare_tbl) +
  geom_line(aes(x = month, y = value, colour = model)) +
  geom_line(aes(x = month, y = value), colour = 'black', data = maine_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Comparison of Maine Unemployment Forecast Models')
```


# Forecast Evaluation

We finally come to the most important part of forecasting - how we decide how
good it is.


## Evaluation Metrics

We start by defining the forecast *error* or forecast *residual*, $e_{t+h}$ as:

$$
e_{t+h} = y_{t+h} - \hat{y}_{t+h \, | \,t}
$$

This is scale-dependent, so we also define the *forecast percentage error*,
$p_t$

$$
p_t = \frac{e_t}{y_t}
$$


where:

\begin{eqnarray*}
y_{t+h} &=& \text{realized value at time } t+h   \\
\hat{y}_{t+h} &=& \text{forecast value at time } t+h
\end{eqnarray*}

From this we build a number of different metrics:

\begin{eqnarray*}
\text{Mean absolute error, MAE}              &=&
    \text{mean}(|e_t|)                                     \\
\text{Root mean square error, RMSE}          &=&
    \sqrt{\text{mean}(e_t^2)}                              \\
\text{Mean absolute percentage error, MAPE}  &=& 
    \text{mean}(|p_t|)                                     \\
\text{Symmetric MAPE}                        &=&
    \frac{200 * |y_t - \hat{y}_t|}{y_t + \hat{y}_t}        \\
\text{Scaled error}, q_j                     &=&
    \frac{e_j}{\frac{1}{T-1} \sum_{t=2}^T |y_t - y_{t-1}|} \\
\text{Mean absolute scaled error, MASE}      &=&
    \text{mean}(|q_j|)
\end{eqnarray*}


## Evaluating Fits

We run the accuracy metrics for both the Air Passenger and the Maine
Unemployment data for the fits we ran.


### Air Passenger Metrics

We now calculate the evaluation metrics for the Air Passenger models.

```{r calculate_ap_metrics, echo=TRUE}
ap_ets_assess_tbl <- list(
  ewma    = ap_ewma_forecast,
  hw      = ap_hw_forecast,
  hwmult  = ap_hwmult_forecast,
  autoets = ap_autoets_forecast
  ) %>%
  map(accuracy, x = ap_test_tbl$value) %>%
  map(as_tibble, rownames = 'type') %>%
  bind_rows(.id = 'model') %>%
  arrange(type, model)

ap_ets_assess_tbl %>% summary()
```

We plot the values.

```{r plot_ap_metrics, echo=TRUE}
plot_tbl <- ap_ets_assess_tbl %>%
  gather('metric', 'value', -model, -type)
  
ggplot(plot_tbl) +
  geom_col(aes(x = model, y = value, fill = type), position = 'dodge') +
  facet_wrap(~ metric, scales = 'free_y') +
  xlab('Model') +
  ylab('Metric') +
  ggtitle('Facet Plot for Air Passenger Forecast Metrics')
```



### Maine Unemployment Metrics

We repeat this process for the Maine Unemployment series.

```{r calculate_maine_metrics, echo=TRUE}
maine_ets_assess_tbl <- list(
  ewma    = maine_ewma_forecast,
  ewma    = maine_ewma_paramfit_forecast,
  hw      = maine_hw_forecast,
  hwmult  = maine_hwmult_forecast,
  autoets = maine_autoets_forecast
  ) %>%
  map(accuracy, x = maine_test_tbl$value) %>%
  map(as_tibble, rownames = 'type') %>%
  bind_rows(.id = 'model') %>%
  arrange(type, model)

maine_ets_assess_tbl %>% summary()
```

We plot the values.

```{r plot_maine_metrics, echo=TRUE}
plot_tbl <- maine_ets_assess_tbl %>%
  gather('metric', 'value', -model, -type)
  
ggplot(plot_tbl) +
  geom_col(aes(x = model, y = value, fill = type), position = 'dodge') +
  facet_wrap(~ metric, scales = 'free_y') +
  xlab('Model') +
  ylab('Metric') +
  ggtitle('Facet Plot for Maine Unemployment Forecast Metrics')
```



# AR, MA and ARMA Models

We now turn our attention to the auto-regressive and moving average model - the
second workhorse for time-series modelling.

## Building Blocks

These models are built from a number of elementary model types that we first
discuss before combining in different ways to model time series data seen in
the real world.


### White Noise Series

A time series $w_t$ is \emph{discrete white noise} if the $w_t$ are i.i.d with
a mean of zero. They all have the same variance $\sigma^2$ and
$\text{Cor}(w_i, w_j) = 0$ for $i \neq j$.

In addition, if $w_j \sim N(0, \sigma^2)$ then it is called
\emph{Gaussian white noise}.


A time series $x_t$ is a \emph{random walk} if

$$
x_t = x_{t-1} + w_t,
$$

where $w_t$ is a white-noise series.


```{r white_noise_series, echo=TRUE}
wn_innov <- rnorm(200, 0, 1)

sim_wn_ts <- arima.sim(list(),
                       n = length(wn_innov),
                       innov = wn_innov,
                       start.innov = rep(0, 100)
                      )

sim_wn_ts_tbl <- sim_wn_ts %>%
  tk_tbl(preserve_index = FALSE) %>%
  add_column(index = 1:length(sim_wn_ts), .before = 1)

ggplot(sim_wn_ts_tbl) +
  geom_line(aes(x = index, y = value)) +
  expand_limits(y = 0) +
  xlab("Index") +
  ylab("Value") +
  ggtitle("Plot of Generated Gaussian White Noise Series")
```

We also produce a standard and partial correlogram, but expect no significant
lags.

```{r white_noise_acf_pacf, echo=TRUE}
sim_wn_ts %>% Acf()  %>% autoplot() + ggtitle("ACF for White Noise Series")
sim_wn_ts %>% Pacf() %>% autoplot() + ggtitle("PACF for White Noise Series")
```


### Autoregressive Process - AR(p)

The time series $x_t$ is an \emph{auto-regressive process of order $p$},
$\text{AR}(p)$, if,

\begin{eqnarray*}
x_t &=& \delta + \alpha_1 x_1 + ... + \alpha_p x_p + w_t \\
    &=& \alpha_0 + \sum^p_{i=1} \alpha_i x_{t-i} + w_t,
\end{eqnarray*}

where

\begin{eqnarray*}
w_t      &=&    \text{is a white-noise process} \\
\delta   &=&    \text{'intercept' value}     \\
\alpha_p &\neq& 0 \text{ for order } p
\end{eqnarray*}


With this definition, we can use this as a *data-generating process* to
construct an example AR(1) model, and visual inspect the results.

```{r generate_ar1_model, echo=TRUE}
sim_ar1_ts <- arima.sim(list(ar = 0.5),
                        n     = length(wn_innov),
                        innov = wn_innov,
                        start.innov = rep(0, 100)
                        )

sim_ar1_ts_tbl <- sim_ar1_ts %>%
  tk_tbl(preserve_index = FALSE) %>%
  add_column(index = 1:length(sim_ar1_ts), .before = 1)

ggplot(sim_ar1_ts_tbl) +
  geom_line(aes(x = index, y = value)) +
  expand_limits(y = 0) +
  xlab("Index") +
  ylab("Value") +
  ggtitle("Plot of Generated AR(1) Series")
```

Having generated the AR(1) process, we now look at the correlogram to see what
it produces.

```{r ar1_acf_pacf, echo=TRUE}
sim_ar1_ts %>% Acf()  %>% autoplot() + ggtitle("ACF for AR(1) Series")
sim_ar1_ts %>% Pacf() %>% autoplot() + ggtitle("PACF for AR(1) Series")
```


Moving on, in a similar fashion we can construct an AR(2) model with the same
innovations, but with $\alpha_1 = 1$, $\alpha_2 = -0.25$:


```{r generate_ar2_model, echo=TRUE}
sim_ar2_ts <- arima.sim(list(ar = c(1, -0.25)),
                        n     = length(wn_innov),
                        innov = wn_innov,
                        start.innov = rep(0, 100)
                         )

sim_ar2_ts_tbl <- sim_ar2_ts %>%
  tk_tbl(preserve_index = FALSE) %>%
  add_column(index = 1:length(sim_ar2_ts), .before = 1)


ggplot(sim_ar2_ts_tbl) +
  geom_line(aes(x = index, y = value)) +
  expand_limits(y = 0) +
  xlab("Index") +
  ylab("Value") +
  ggtitle("Plot of Generated AR(2) Series")
```

We also look at the correlogram for this series.

```{r ar2_acf_pacf, echo=TRUE}
sim_ar2_ts %>% Acf()  %>% autoplot() + ggtitle("ACF for AR(2) Series")
sim_ar2_ts %>% Pacf() %>% autoplot() + ggtitle("PACF for AR(2) Series")
```



We can try a number of different parameters here to see the effect - we try
another AR(2) but this time with both parameters positive:


```{r generate_ar2alt_model, echo=TRUE}
sim_ar2alt_ts <- arima.sim(list(ar = c(0.5, 0.4)),
                           n     = length(wn_innov),
                           innov = wn_innov,
                           start.innov = rep(0, 100)
                           )

sim_ar2alt_ts_tbl <- sim_ar2alt_ts %>%
  tk_tbl(preserve_index = FALSE) %>%
  add_column(index = 1:length(sim_ar2alt_ts), .before = 1)


ggplot(sim_ar2alt_ts_tbl) +
  geom_line(aes(x = index, y = value)) +
  expand_limits(y = 0) +
  xlab("Index") +
  ylab("Value") +
  ggtitle("Plot of Generated Alternate AR(2) Series")
```

And the correlogram for this alternate AR(2) series.

```{r ar2alt_acf_pacf, echo=TRUE}
sim_ar2alt_ts %>% Acf()  %>% autoplot() + ggtitle("ACF for Alternate AR(2) Series")
sim_ar2alt_ts %>% Pacf() %>% autoplot() + ggtitle("ACF for Alternate AR(2) Series")
```

To help with intuition we plot these generated data together.

```{r plot_generated_ar_series, echo=TRUE}
sim_compare_tbl <- list(
  wn     = sim_wn_ts_tbl,
  ar1    = sim_ar1_ts_tbl,
  ar2    = sim_ar2_ts_tbl,
  ar2alt = sim_ar2alt_ts_tbl
  ) %>%
  bind_rows(.id = 'model')


ggplot(sim_compare_tbl) +
  geom_line(aes(x = index, y = value, colour = model)) +
  xlab("Index") +
  ylab("Value") +
  ggtitle("Generated AR Models Comparison Plot")
```


### Moving Average Process - MA(q)

A moving average (MA) process of order $q$ is a linear combination of the
current white noise term and the $q$ most recent past white noise terms,

\begin{eqnarray*}
x_t &=& w_t + \gamma + \beta_1 w_1 + ... + \beta_q w_q \\
    &=& \gamma + w_t + \sum^q_{i=1} \beta_i w_{t-i}
\end{eqnarray*}

where $w_t$ is a white-noise process with mean 0 and variance $\sigma^2$.

\begin{eqnarray*}
w_t     &=&    \text{is a white-noise process with mean 0 and variance } \sigma^2 \\
\gamma  &=&    \text{'intercept' value}     \\
\beta_q &\neq& 0 \text{ for order } q
\end{eqnarray*}


```{r generate_ma1_model, echo=TRUE}
sim_ma1_ts <- arima.sim(list(ma = 0.5),
                        n     = length(wn_innov),
                        innov = wn_innov,
                        start.innov = rep(0, 100)
                        )

sim_ma1_ts_tbl <- sim_ma1_ts %>%
  tk_tbl(preserve_index = FALSE) %>%
  add_column(index = 1:length(sim_ma1_ts), .before = 1)

ggplot(sim_ma1_ts_tbl) +
  geom_line(aes(x = index, y = value)) +
  expand_limits(y = 0) +
  xlab("Index") +
  ylab("Value") +
  ggtitle("Plot of Generated MA(1) Series")
```

We check the MA(1) correlogram:

```{r ma1_acf_pacf, echo=TRUE}
sim_ma1_ts %>% Acf()  %>% autoplot() + ggtitle("ACF for MA(1) Series")
sim_ma1_ts %>% Pacf() %>% autoplot() + ggtitle("ACF for MA(1) Series")
```


Like we did before, we now generate an MA(2) model.

```{r generate_ma2_model, echo=TRUE}
sim_ma2_ts <- arima.sim(list(ma = c(1, -0.25)),
                        n     = length(wn_innov),
                        innov = wn_innov,
                        start.innov = rep(0, 100)
                         )

sim_ma2_ts_tbl <- sim_ma2_ts %>%
  tk_tbl(preserve_index = FALSE) %>%
  add_column(index = 1:length(sim_ma2_ts), .before = 1)


ggplot(sim_ma2_ts_tbl) +
  geom_line(aes(x = index, y = value)) +
  expand_limits(y = 0) +
  xlab("Index") +
  ylab("Value") +
  ggtitle("Plot of Generated MA(2) Series")
```

Once again we look at the MA(2) series.

```{r ma2_acf_pacf, echo=TRUE}
sim_ma2_ts %>% Acf()  %>% autoplot() + ggtitle("ACF for MA(2) Series")
sim_ma2_ts %>% Pacf() %>% autoplot() + ggtitle("ACF for MA(2) Series")
```


```{r plot_generated_ma_series, echo=TRUE}
sim_compare_tbl <- list(
  wn  = sim_wn_ts_tbl,
  ma1 = sim_ma1_ts_tbl,
  ma2 = sim_ma2_ts_tbl
  ) %>%
  bind_rows(.id = 'model')


ggplot(sim_compare_tbl) +
  geom_line(aes(x = index, y = value, colour = model)) +
  xlab("Index") +
  ylab("Value") +
  ggtitle("Generated MA Models Comparison Plot")
```


### Comparing AR and MA Models

Before moving on to ARMA and ARIMA models we combine all our generated series
and plot them all against each other.

```{r plot_generated_ar_ma_series, echo=TRUE}
sim_compare_tbl <- list(
  wn     = sim_wn_ts_tbl,
  ar1    = sim_ar1_ts_tbl,
  ar2    = sim_ar2_ts_tbl,
  ar2alt = sim_ar2alt_ts_tbl,
  ma1    = sim_ma1_ts_tbl,
  ma2    = sim_ma2_ts_tbl
  ) %>%
  bind_rows(.id = 'model')


ggplot(sim_compare_tbl) +
  geom_line(aes(x = index, y = value, colour = model)) +
  xlab("Index") +
  ylab("Value") +
  ggtitle("Generated AR and MA Models Comparison Plot")
```


## ARMA and ARIMA Models

Autoregressive moving-average models combine both the AR and MA models
together. The benefit of combining both models is due to the
*principle of parsimony* - given two equal quality models, we prefer the one
with the lower number of parameters.

In general, ARMA models fit time series with a lower number of parameters than
either AR or MA models alone, so they are preferred.

More formally, we define an $\text{ARMA}(p, q)$ model to be

$$
x_t = \sum_{i=1}^p \alpha_i x_{t-i} + w_t + \sum_{j=1}^q \beta_j w_{t-j}
$$

where $w_t$ is white noise.

Both $\text{AR}(p)$ and $\text{MA}(q)$ models are special cases of
$\text{ARMA}(p, q)$ (with $q = 0$ and $p = 0$ respectively).

We now fit an $\text{ARMA}(1, 1)$ model using the same white-noise innovations
as before.


```{r generate_arma_1_1_model, echo=TRUE}
sim_arma_1_1_ts <- arima.sim(list(ar = 0.5, ma = 0.5),
                             n     = length(wn_innov),
                             innov = wn_innov,
                             start.innov = rep(0, 100)
                             )

sim_arma_1_1_ts_tbl <- sim_arma_1_1_ts %>%
  tk_tbl(preserve_index = FALSE) %>%
  add_column(index = 1:length(sim_arma_1_1_ts), .before = 1)

ggplot(sim_arma_1_1_ts_tbl) +
  geom_line(aes(x = index, y = value)) +
  expand_limits(y = 0) +
  xlab("Index") +
  ylab("Value") +
  ggtitle("Plot of Generated ARMA(1,1) Series")
```

We use `auto.arima()` to fit parameters for this data to see if we recover the
given parameters.

```{r fit_sim_arma_1_1, echo=TRUE}
sim_arma_1_1_ts %>%
  auto.arima() %>%
  sw_tidy()
```


### ARIMA Models

As discussed earlier, it is often more effective to model the differences in
a time series rather than the raw values.

A variant of the ARMA is the *Auto-Regressive Integrated Moving Average* model
which applies the ARMA model to the differences. ARIMA model are specified With
a third order value, $d$ - the order of the differences, and so are described
as $\text{ARIMA}(p, d, q)$ models.

While there is no theoretical limit to $d$, in practice it is uncommon to see
$d > 1$.


## Fitting ARMA and ARIMA Models

We now turn our attention to fitting ARMA and ARIMA models.

In some cases, we use a combination of domain knowledge and autocorrelation
analysis to determine the order of the AR(I)MA model we fit, but generally we
go with the best fit as determined by AIC or BIC (and ensure this 'best' fit
is still useful and makes sense).


### Fitting the Air Passenger Data

As always, we start with the Air Passenger data.

Purely for illustration, we start with the ARIMA(1, 0, 1) model - which is
equivalent to the ARMA(1, 1) - and then try the ARIMA(1, 1, 1).

```{r fit_ap_arma_1_1_arima, echo=TRUE}
ap_arma_1_1_fit <- ap_train_tbl %>%
  tk_ts(select = value, start = 1949, frequency = 12) %>%
  Arima(order = c(1, 0, 1))

ap_arma_1_1_forecast <- ap_arma_1_1_fit %>%
  forecast(h = 12, level = c(50, 80))

ap_arma_1_1_forecast_tbl <- ap_arma_1_1_forecast %>%
  sw_sweep(rename_index = 'month')


ap_arma_1_1_fit %>% sw_tidy()
ap_arma_1_1_fit %>% sw_glance()


ggplot(ap_arma_1_1_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = ap_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Air Passenger Forecast for ARMA(1, 1) Model')
```

This is not a good model.

```{r fit_ap_arma_1_1_1_arima, echo=TRUE}
ap_arma_1_1_1_fit <- ap_train_tbl %>%
  tk_ts(select = value, start = 1949, frequency = 12) %>%
  Arima(order = c(1, 1, 1))

ap_arma_1_1_1_forecast <- ap_arma_1_1_1_fit %>%
  forecast(h = 12, level = c(50, 80))

ap_arma_1_1_1_forecast_tbl <- ap_arma_1_1_1_forecast %>%
  sw_sweep(rename_index = 'month')


ap_arma_1_1_1_fit %>% sw_tidy()
ap_arma_1_1_1_fit %>% sw_glance()


ggplot(ap_arma_1_1_1_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = ap_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Air Passenger Forecast for ARIMA(1, 1, 1) Model')
```

This is not a good model either. We need to include a seasonal component to
this process to use it properly.

Before we move on, we try using the `auto.arima()` function to see what the
best model looks like.

```{r ap_autoarima_fit, echo=TRUE}
ap_autoarima_fit <- ap_train_tbl %>%
  tk_ts(select = value, start = 1949, frequency = 12) %>%
  auto.arima(seasonal = FALSE)

ap_autoarima_forecast <- ap_autoarima_fit %>%
  forecast(h = 12, level = c(50, 80))

ap_autoarima_forecast_tbl <- ap_autoarima_forecast %>%
  sw_sweep(rename_index = 'month')


ap_autoarima_fit %>% sw_tidy()
ap_autoarima_fit %>% sw_glance()


ggplot(ap_autoarima_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = ap_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Air Passenger Forecast for Auto-ARIMA Model')
```

We will look at including seasonal elements to the ARIMA model shortly.


### Fitting the Maine Unemployment Data

We will not try to fit any particular order of ARIMA model for the Maine
Unemployment data and move straight to using `auto.arima()` to fit the models.

```{r maine_autoarima_fit, echo=TRUE}
maine_autoarima_fit <- maine_train_tbl %>%
  tk_ts(select = value, start = 1996, frequency = 12) %>%
  auto.arima(seasonal = FALSE)

maine_autoarima_forecast <- maine_autoarima_fit %>%
  forecast(h = 20, level = c(50, 80))

maine_autoarima_forecast_tbl <- maine_autoarima_forecast %>%
  sw_sweep(rename_index = 'month')

maine_autoarima_fit %>% sw_tidy()
maine_autoarima_fit %>% sw_glance()


ggplot(maine_autoarima_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = maine_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Maine Unemployment Forecast for Auto-ARIMA Model')
```


## Seasonal ARIMA Models

We add seasonality to an ARIMA model by adding separate analysis for the
seasonal component of the time series.

Full detail of this approach is beyond the scope of this workshop, but we
specify a SARIMA model as $\text{SARIMA}(p, d, q)(P, D, Q)_m$, where the capitals
$(P, D, Q)$ are for the seasonal part of the model, with $m$ denoting the
number of data points per seasonal cycle - so we have $m = 12$ for monthly
data with annual seasonality.

### Fitting SARIMA Models

Fitting a Seasonal-ARIMA is a matter of adding the `seasonal = TRUE` parameter
to `auto.arima()`.

We now fit SARIMA models for both the Air Passenger and Maine Unemployment
data.

```{r ap_sarima_fit, echo=TRUE}
ap_sarima_fit <- ap_train_tbl %>%
  tk_ts(select = value, start = 1949, frequency = 12) %>%
  auto.arima(seasonal = TRUE)

ap_sarima_forecast <- ap_sarima_fit %>%
  forecast(h = 12, level = c(50, 80))

ap_sarima_forecast_tbl <- ap_sarima_forecast %>%
  sw_sweep(rename_index = 'month')


ap_sarima_fit %>% sw_tidy()
ap_sarima_fit %>% sw_glance()


ggplot(ap_sarima_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = ap_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Air Passenger Forecast for Seasonal ARIMA Model')
```


Now we fit the Maine Unemployment data.


```{r maine_sarima_fit, echo=TRUE}
maine_sarima_fit <- maine_train_tbl %>%
  tk_ts(select = value, start = 1996, frequency = 12) %>%
  auto.arima(seasonal = TRUE)

maine_sarima_forecast <- maine_sarima_fit %>%
  forecast(h = 20, level = c(50, 80))

maine_sarima_forecast_tbl <- maine_sarima_forecast %>%
  sw_sweep(rename_index = 'month')


maine_sarima_fit %>% sw_tidy()
maine_sarima_fit %>% sw_glance()


ggplot(maine_sarima_forecast_tbl) +
  geom_line(aes(x = month, y = value, colour = key)) +
  geom_ribbon(aes(x = month, ymin = lo.50, ymax = hi.50), alpha = 0.2) +
  geom_line  (aes(x = month, y = value), colour = 'red', data = maine_test_tbl) +
  expand_limits(y = 0) +
  xlab("Date") +
  ylab("Count") +
  scale_x_yearmon() +
  ggtitle('Maine Unemployment Forecast for Seasonal ARIMA Model')
```



## Forecast Evaluation

We now run forecast evaluations metrics for all our forecasts.


### Air Passenger Forecasts

We run the data for the Air Passenger data.

```{r calculate_ap_evaluations, echo=TRUE}
ap_metrics_tbl <- ls(pattern = '^ap_.*_forecast$') %>%
  enframe(value = 'variable') %>%
  mutate(model    = str_replace(variable, 'ap_(.*)_forecast', '\\1'),
         data     = map(variable, get),
         accuracy = map(data, accuracy, x = ap_test_tbl$value),
         acc_tbl  = map(accuracy, as_tibble, rownames = 'type')) %>%
  select(model, acc_tbl) %>%
  unnest() %>%
  arrange(type, model)

ap_metrics_tbl %>% summary()
```


```{r plot_full_ap_metrics, echo=TRUE}
plot_tbl <- ap_metrics_tbl %>%
  gather('metric', 'value', -model, -type)
  
ggplot(plot_tbl) +
  geom_col(aes(x = model, y = value, fill = type), position = 'dodge') +
  facet_wrap(~ metric, scales = 'free_y') +
  xlab('Model') +
  ylab('Metric') +
  ggtitle('Facet Plot for Air Passenger Forecast Metrics') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
```


### Maine Unemployment Forecasts

And we run the data for the Maine Unemployment time series.

```{r calculate_maine_evaluations, echo=TRUE}
maine_metrics_tbl <- ls(pattern = '^maine_.*_forecast$') %>%
  enframe(value = 'variable') %>%
  mutate(model    = str_replace(variable, 'maine_(.*)_forecast', '\\1'),
         data     = map(variable, get),
         accuracy = map(data, accuracy, x = maine_test_tbl$value),
         acc_tbl  = map(accuracy, as_tibble, rownames = 'type')) %>%
  select(model, acc_tbl) %>%
  unnest() %>%
  arrange(type, model)

maine_metrics_tbl %>% summary()
```

```{r plot_full_maine_metrics, echo=TRUE}
plot_tbl <- maine_metrics_tbl %>%
  gather('metric', 'value', -model, -type)
  
ggplot(plot_tbl) +
  geom_col(aes(x = model, y = value, fill = type), position = 'dodge') +
  facet_wrap(~ metric, scales = 'free_y') +
  xlab('Model') +
  ylab('Metric') +
  ggtitle('Facet Plot for Maine Unemployment Forecast Metrics') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
```

Addtional Information
====================================

### R Environment

```{r show_session_info, echo=TRUE, message=TRUE}
devtools::session_info()
```
